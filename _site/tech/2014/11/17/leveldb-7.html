<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">

    <title>和我一起学习leveldb [7 util(续)]</title>
    <meta name="description" content="岂能尽如人意 但求无愧我心
">

    <link rel="stylesheet" href="/css/main.css">
    <link rel="canonical" href="http://someaddr.com/tech/2014/11/17/leveldb-7.html">

</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Blog of Finesse</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">和我一起学习leveldb [7 util(续)]</h1>
    <p class="post-meta">Nov 17, 2014</p>
  </header>

  <article class="post-content">
    <h1 id="section">[缓存]</h1>

<p>这一篇将分析leveldb的cache，请容我慢慢道来。提醒大家一下，上一篇以前你们看到的内容是还没有写完的，今天花了点时间把上一篇抽象环境分析完了，内容很多很杂很丰富，同学们再去看两眼哦，同时别忘了给我的github的这个博客项目加颗星星。</p>

<p>由于鄙人最近工作比较忙，时间有点紧，所以请大家耐心等待，本篇内容我尽量保证在12月中旬写完，谢谢大家！</p>

<p><strong>arena</strong>是轻量级的内存池，设计很简单，其数据结构如下图所示：</p>

<pre><code>           arena
+------------------------+
|       alloc_ptr_       | ---------------------------+
+------------------------+                            |
| alloc_bytes_remaining_ |                            |
+------------------------+                            .
| vector&lt;char*&gt; blocks_  | ---&gt; +----------+------+----------+--------------+
+------------------------+      |  block1  |block2|  block3  |    block4    |
|     blocks_memory_     |      +----------+------+----------+--------------+
+------------------------+         1 page    x B     1 page        y B

对于一次大于1/4 page的内存分配请求，如果目前块剩下的部分不够，
就直接分配一个一块所需大小的内存（避免浪费当前块），单独作为一个block(例如x,y)
</code></pre>

<p><strong>arena</strong>的逻辑很简单，用一个<code>vector&lt;char *&gt;</code>来维护所有分配的内存。alloc_ptr_指向当前内存池中可以分配内存的起始点。当一个内存分配请求x字节的内存时，先看alloc_ptr_到该块末尾还有多少内存(这个记录在alloc_bytes_remaining_中)，如果该块内存够，新申请的内存首地址就是现在的alloc_ptr<em>，然后把alloc_ptr_朝后面移动x字节，并重新计算alloc_bytes_remaining</em>。如果该块剩下的内存不够了，就看x是否大于1/4 page，如果不大于1/4page，说明当前块剩下的不足1/4了，那么就直接分配一个新的block(1 page)，把alloc_ptr_的置为新block的首地址，再按之前的逻辑进行分配，旧的块剩余的内存就被浪费掉了。新申请的block被pushback到blocks_中，以后在arena被析构的时候统一释放。如果内存分配请求大于1/4个pagesize，为了避免浪费当前块剩下的内存，就直接向操作系统申请x字节的内存，作为一个单独的block返回，这个block同样也会被pushback到vector之中。把机理分析完毕之后，再贴代码就很好读懂了：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="k">class</span> <span class="nc">Arena</span> <span class="p">{</span>
<span class="lineno"> 2</span>     <span class="k">public</span><span class="o">:</span>
<span class="lineno"> 3</span>         <span class="n">Arena</span><span class="p">();</span>
<span class="lineno"> 4</span>         <span class="o">~</span><span class="n">Arena</span><span class="p">();</span>
<span class="lineno"> 5</span> 
<span class="lineno"> 6</span>         <span class="c1">// Return a pointer to a newly allocated memory block of &quot;bytes&quot; bytes.</span>
<span class="lineno"> 7</span>         <span class="kt">char</span><span class="o">*</span> <span class="nf">Allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span>         <span class="c1">// Allocate memory with the normal alignment guarantees provided by malloc</span>
<span class="lineno">10</span>         <span class="kt">char</span><span class="o">*</span> <span class="nf">AllocateAligned</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="lineno">11</span> 
<span class="lineno">12</span>         <span class="c1">// Returns an estimate of the total memory usage of data allocated</span>
<span class="lineno">13</span>         <span class="c1">// by the arena (including space allocated but not yet used for user</span>
<span class="lineno">14</span>         <span class="c1">// allocations).</span>
<span class="lineno">15</span>         <span class="kt">size_t</span> <span class="nf">MemoryUsage</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
<span class="lineno">16</span>             <span class="k">return</span> <span class="n">blocks_memory_</span> <span class="o">+</span> <span class="n">blocks_</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
<span class="lineno">17</span>         <span class="p">}</span>
<span class="lineno">18</span> 
<span class="lineno">19</span>     <span class="k">private</span><span class="o">:</span>
<span class="lineno">20</span>         <span class="kt">char</span><span class="o">*</span> <span class="n">AllocateFallback</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">);</span>
<span class="lineno">21</span>         <span class="kt">char</span><span class="o">*</span> <span class="nf">AllocateNewBlock</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">block_bytes</span><span class="p">);</span>
<span class="lineno">22</span> 
<span class="lineno">23</span>         <span class="c1">// Allocation state</span>
<span class="lineno">24</span>         <span class="kt">char</span><span class="o">*</span> <span class="n">alloc_ptr_</span><span class="p">;</span>
<span class="lineno">25</span>         <span class="kt">size_t</span> <span class="n">alloc_bytes_remaining_</span><span class="p">;</span>
<span class="lineno">26</span> 
<span class="lineno">27</span>         <span class="c1">// Array of new[] allocated memory blocks</span>
<span class="lineno">28</span>         <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span> <span class="n">blocks_</span><span class="p">;</span>
<span class="lineno">29</span> 
<span class="lineno">30</span>         <span class="c1">// Bytes of memory in blocks allocated so far</span>
<span class="lineno">31</span>         <span class="kt">size_t</span> <span class="n">blocks_memory_</span><span class="p">;</span>
<span class="lineno">32</span> 
<span class="lineno">33</span>         <span class="c1">// No copying allowed</span>
<span class="lineno">34</span>         <span class="n">Arena</span><span class="p">(</span><span class="k">const</span> <span class="n">Arena</span><span class="o">&amp;</span><span class="p">);</span>
<span class="lineno">35</span>         <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Arena</span><span class="o">&amp;</span><span class="p">);</span>
<span class="lineno">36</span> <span class="p">};</span>
<span class="lineno">37</span> 
<span class="lineno">38</span> <span class="kr">inline</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Arena</span><span class="o">::</span><span class="n">Allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">39</span>     <span class="c1">// The semantics of what to return are a bit messy if we allow</span>
<span class="lineno">40</span>     <span class="c1">// 0-byte allocations, so we disallow them here (we don&#39;t need</span>
<span class="lineno">41</span>     <span class="c1">// them for our internal use).</span>
<span class="lineno">42</span>     <span class="n">assert</span><span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="lineno">43</span>     <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&lt;=</span> <span class="n">alloc_bytes_remaining_</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">44</span>         <span class="kt">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">alloc_ptr_</span><span class="p">;</span>
<span class="lineno">45</span>         <span class="n">alloc_ptr_</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
<span class="lineno">46</span>         <span class="n">alloc_bytes_remaining_</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
<span class="lineno">47</span>         <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="lineno">48</span>     <span class="p">}</span>
<span class="lineno">49</span>     <span class="k">return</span> <span class="n">AllocateFallback</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
<span class="lineno">50</span> <span class="p">}</span></code></pre></div>

<p>在`Arena::Allocate函数的实现中，我们看到，如果当前块放不下了，就调用AllocateFallback。AllocateFallback会根据当前申请的内存大小，去单独向操作系统申请一个块给这次请求，或者另分配一个内存块，把当前的块剩下的内存浪费掉：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">kBlockSize</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="n">Arena</span><span class="o">::</span><span class="n">Arena</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno"> 4</span>     <span class="n">blocks_memory_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno"> 5</span>     <span class="n">alloc_ptr_</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">// First allocation will allocate a block</span>
<span class="lineno"> 6</span>     <span class="n">alloc_bytes_remaining_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno"> 7</span> <span class="p">}</span>
<span class="lineno"> 8</span> 
<span class="lineno"> 9</span> <span class="n">Arena</span><span class="o">::~</span><span class="n">Arena</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno">10</span>     <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">blocks_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">11</span>         <span class="k">delete</span><span class="p">[]</span> <span class="n">blocks_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="lineno">12</span>     <span class="p">}</span>
<span class="lineno">13</span> <span class="p">}</span>
<span class="lineno">14</span> 
<span class="lineno">15</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Arena</span><span class="o">::</span><span class="n">AllocateFallback</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">16</span>     <span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">kBlockSize</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">17</span>         <span class="c1">// Object is more than a quarter of our block size.  Allocate it separately</span>
<span class="lineno">18</span>         <span class="c1">// to avoid wasting too much space in leftover bytes.</span>
<span class="lineno">19</span>         <span class="kt">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">AllocateNewBlock</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
<span class="lineno">20</span>         <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="lineno">21</span>     <span class="p">}</span>
<span class="lineno">22</span> 
<span class="lineno">23</span>     <span class="c1">// We waste the remaining space in the current block.</span>
<span class="lineno">24</span>     <span class="n">alloc_ptr_</span> <span class="o">=</span> <span class="n">AllocateNewBlock</span><span class="p">(</span><span class="n">kBlockSize</span><span class="p">);</span>
<span class="lineno">25</span>     <span class="n">alloc_bytes_remaining_</span> <span class="o">=</span> <span class="n">kBlockSize</span><span class="p">;</span>
<span class="lineno">26</span> 
<span class="lineno">27</span>     <span class="kt">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">alloc_ptr_</span><span class="p">;</span>
<span class="lineno">28</span>     <span class="n">alloc_ptr_</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
<span class="lineno">29</span>     <span class="n">alloc_bytes_remaining_</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
<span class="lineno">30</span>     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="lineno">31</span> <span class="p">}</span>
<span class="lineno">32</span> 
<span class="lineno">33</span> <span class="c1">// 分配一个大小为block_bytes的内存块，并挂在vector后面</span>
<span class="lineno">34</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Arena</span><span class="o">::</span><span class="n">AllocateNewBlock</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">block_bytes</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno">35</span>   <span class="kt">char</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">block_bytes</span><span class="p">];</span>
<span class="lineno">36</span>   <span class="n">blocks_memory_</span> <span class="o">+=</span> <span class="n">block_bytes</span><span class="p">;</span>
<span class="lineno">37</span>   <span class="n">blocks_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="lineno">38</span>   <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="lineno">39</span> <span class="p">}</span></code></pre></div>

<p>关于Arena，最后再提一下Arena里面提供的内存对齐分配接口。读了<code>Arena::Allocate</code>的代码，我们知道Arena的Allocate返回的内存地址是不保证任何对齐的。然而如果我们使用malloc簇函数，返回的内存默认是sizeof(void *)对齐的（关于这一点，很多同学是不清楚的，我觉得如果要写好C/C++程序，必须对malloc的机制有一定的了解，例如malloc是如何对齐的，malloc分配的内存块被溢出会出现什么情况，如果要分配一段内存并且自定义字节对齐怎么办等等）。因此在Arena中也提供了返回地址内存对齐的分配函数<code>Arena::AllocateAligned</code>。其实实现内存对齐相当简单，只需计算当前的alloc_ptr_的地址，多分配几个字节，返回内存对齐的地址就可以了。</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno"> 1</span> <span class="kt">char</span><span class="o">*</span> <span class="n">Arena</span><span class="o">::</span><span class="n">AllocateAligned</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 2</span>     <span class="k">const</span> <span class="kt">int</span> <span class="n">align</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>    <span class="c1">// We&#39;ll align to pointer size</span>
<span class="lineno"> 3</span>     <span class="n">assert</span><span class="p">((</span><span class="n">align</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">align</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>   <span class="c1">// Pointer size should be a power of 2</span>
<span class="lineno"> 4</span>     <span class="kt">size_t</span> <span class="n">current_mod</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">alloc_ptr_</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">align</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="lineno"> 5</span>     <span class="kt">size_t</span> <span class="n">slop</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_mod</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">align</span> <span class="o">-</span> <span class="n">current_mod</span><span class="p">);</span>
<span class="lineno"> 6</span>     <span class="kt">size_t</span> <span class="n">needed</span> <span class="o">=</span> <span class="n">bytes</span> <span class="o">+</span> <span class="n">slop</span><span class="p">;</span>
<span class="lineno"> 7</span>     <span class="kt">char</span><span class="o">*</span> <span class="n">result</span><span class="p">;</span>
<span class="lineno"> 8</span>     <span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&lt;=</span> <span class="n">alloc_bytes_remaining_</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 9</span>         <span class="n">result</span> <span class="o">=</span> <span class="n">alloc_ptr_</span> <span class="o">+</span> <span class="n">slop</span><span class="p">;</span>
<span class="lineno">10</span>         <span class="n">alloc_ptr_</span> <span class="o">+=</span> <span class="n">needed</span><span class="p">;</span>
<span class="lineno">11</span>         <span class="n">alloc_bytes_remaining_</span> <span class="o">-=</span> <span class="n">needed</span><span class="p">;</span>
<span class="lineno">12</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno">13</span>         <span class="c1">// AllocateFallback always returned aligned memory</span>
<span class="lineno">14</span>         <span class="n">result</span> <span class="o">=</span> <span class="n">AllocateFallback</span><span class="p">(</span><span class="n">bytes</span><span class="p">);</span>
<span class="lineno">15</span>     <span class="p">}</span>
<span class="lineno">16</span>     <span class="n">assert</span><span class="p">((</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">align</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
<span class="lineno">17</span>     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="lineno">18</span> <span class="p">}</span></code></pre></div>

<p>值得一提的是第13行的注释说，<code>AllocateFallback</code>函数返回的内存总是内存对齐的。这是因为<code>AllocateFallback</code>中分配内存调用了<code>AllocateNewBlock</code>，而<code>AllocateNewBlock</code>里面是直接调用<code>new</code>算子进行内存分配的。标准库的<code>new</code>实现是对于小于128字节的内存分配，自己维护了一个内存池，内存池中是按8、16、…、128字节维护<code>free list</code>的，而对于超过128字节的内存分配请求，直接调用calloc进行内存分配，因此<code>new</code>算子返回的地址一定是8字节对齐的。关于这部分，有兴趣的同学请参考由<a href="http://www.hust.edu.cn"><strong>华中科技大学</strong></a>出版社出版的《STL源码剖析》的第二章（请原谅我在这里为母校加了一个链接 :) ）。</p>

<p>至此，Arena的实现就全部分析完毕了，接下来我们来看看如何利用Arena实现一个Cache。</p>

<p>在理解leveldb的cache实现中，要理解三个数据结构，一是<strong>HandleTable</strong>，这是一个经典的HashTable的实现，HashTable里面的每个元素除了有一个hash链的指针next_hash外，另外再附带prev和next指针，将所有的Handle链接起来成一个双向链表，用于实现第二个数据结构<strong>LRUCache</strong>。第三个是<strong>ShardedLRUCache</strong>，它是用来管理多个<strong>LRUCache</strong>的。我们先来看一下HashTable:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="lineno">  1</span> <span class="c1">// An entry is a variable length heap-allocated structure.  Entries</span>
<span class="lineno">  2</span> <span class="c1">// are kept in a circular doubly linked list ordered by access time.</span>
<span class="lineno">  3</span> <span class="k">struct</span> <span class="n">LRUHandle</span> <span class="p">{</span>
<span class="lineno">  4</span>   <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">;</span>
<span class="lineno">  5</span>   <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">deleter</span><span class="p">)(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">value</span><span class="p">);</span>
<span class="lineno">  6</span>   <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">next_hash</span><span class="p">;</span>
<span class="lineno">  7</span>   <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
<span class="lineno">  8</span>   <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>
<span class="lineno">  9</span>   <span class="kt">size_t</span> <span class="n">charge</span><span class="p">;</span>      <span class="c1">// TODO(opt): Only allow uint32_t?</span>
<span class="lineno"> 10</span>   <span class="kt">size_t</span> <span class="n">key_length</span><span class="p">;</span>
<span class="lineno"> 11</span>   <span class="kt">uint32_t</span> <span class="n">refs</span><span class="p">;</span>
<span class="lineno"> 12</span>   <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">;</span>      <span class="c1">// Hash of key(); used for fast sharding and comparisons</span>
<span class="lineno"> 13</span>   <span class="kt">char</span> <span class="n">key_data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>   <span class="c1">// Beginning of key</span>
<span class="lineno"> 14</span> 
<span class="lineno"> 15</span>   <span class="n">Slice</span> <span class="nf">key</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
<span class="lineno"> 16</span>     <span class="c1">// For cheaper lookups, we allow a temporary Handle object</span>
<span class="lineno"> 17</span>     <span class="c1">// to store a pointer to a key in &quot;value&quot;.</span>
<span class="lineno"> 18</span>     <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 19</span>       <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Slice</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="lineno"> 20</span>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="lineno"> 21</span>       <span class="k">return</span> <span class="n">Slice</span><span class="p">(</span><span class="n">key_data</span><span class="p">,</span> <span class="n">key_length</span><span class="p">);</span>
<span class="lineno"> 22</span>     <span class="p">}</span>
<span class="lineno"> 23</span>   <span class="p">}</span>
<span class="lineno"> 24</span> <span class="p">};</span>
<span class="lineno"> 25</span> 
<span class="lineno"> 26</span> <span class="k">class</span> <span class="nc">HandleTable</span> <span class="p">{</span>
<span class="lineno"> 27</span>  <span class="k">public</span><span class="o">:</span>
<span class="lineno"> 28</span>   <span class="n">HandleTable</span><span class="p">()</span> <span class="o">:</span> <span class="n">length_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">elems_</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">list_</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="n">Resize</span><span class="p">();</span> <span class="p">}</span>
<span class="lineno"> 29</span>   <span class="o">~</span><span class="n">HandleTable</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">list_</span><span class="p">;</span> <span class="p">}</span>
<span class="lineno"> 30</span> 
<span class="lineno"> 31</span>   <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">Lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 32</span>     <span class="k">return</span> <span class="o">*</span><span class="n">FindPointer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
<span class="lineno"> 33</span>   <span class="p">}</span>
<span class="lineno"> 34</span> 
<span class="lineno"> 35</span>   <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">Insert</span><span class="p">(</span><span class="n">LRUHandle</span><span class="o">*</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 36</span>     <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">FindPointer</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">(),</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">);</span>
<span class="lineno"> 37</span>     <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">old</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="lineno"> 38</span>     <span class="n">h</span><span class="o">-&gt;</span><span class="n">next_hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="nb">NULL</span> <span class="o">:</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">next_hash</span><span class="p">);</span>
<span class="lineno"> 39</span>     <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
<span class="lineno"> 40</span>     <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 41</span>       <span class="o">++</span><span class="n">elems_</span><span class="p">;</span>
<span class="lineno"> 42</span>       <span class="k">if</span> <span class="p">(</span><span class="n">elems_</span> <span class="o">&gt;</span> <span class="n">length_</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 43</span>         <span class="c1">// Since each cache entry is fairly large, we aim for a small</span>
<span class="lineno"> 44</span>         <span class="c1">// average linked list length (&lt;= 1).</span>
<span class="lineno"> 45</span>         <span class="n">Resize</span><span class="p">();</span>
<span class="lineno"> 46</span>       <span class="p">}</span>
<span class="lineno"> 47</span>     <span class="p">}</span>
<span class="lineno"> 48</span>     <span class="k">return</span> <span class="n">old</span><span class="p">;</span>
<span class="lineno"> 49</span>   <span class="p">}</span>
<span class="lineno"> 50</span> 
<span class="lineno"> 51</span>   <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">Remove</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 52</span>     <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">FindPointer</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">hash</span><span class="p">);</span>
<span class="lineno"> 53</span>     <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="lineno"> 54</span>     <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 55</span>       <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">next_hash</span><span class="p">;</span>
<span class="lineno"> 56</span>       <span class="o">--</span><span class="n">elems_</span><span class="p">;</span>
<span class="lineno"> 57</span>     <span class="p">}</span>
<span class="lineno"> 58</span>     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="lineno"> 59</span>   <span class="p">}</span>
<span class="lineno"> 60</span> 
<span class="lineno"> 61</span>  <span class="k">private</span><span class="o">:</span>
<span class="lineno"> 62</span>   <span class="c1">// The table consists of an array of buckets where each bucket is</span>
<span class="lineno"> 63</span>   <span class="c1">// a linked list of cache entries that hash into the bucket.</span>
<span class="lineno"> 64</span>   <span class="kt">uint32_t</span> <span class="n">length_</span><span class="p">;</span>
<span class="lineno"> 65</span>   <span class="kt">uint32_t</span> <span class="n">elems_</span><span class="p">;</span>
<span class="lineno"> 66</span>   <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">list_</span><span class="p">;</span>
<span class="lineno"> 67</span> 
<span class="lineno"> 68</span>   <span class="c1">// Return a pointer to slot that points to a cache entry that</span>
<span class="lineno"> 69</span>   <span class="c1">// matches key/hash.  If there is no such cache entry, return a</span>
<span class="lineno"> 70</span>   <span class="c1">// pointer to the trailing slot in the corresponding linked list.</span>
<span class="lineno"> 71</span>   <span class="n">LRUHandle</span><span class="o">**</span> <span class="nf">FindPointer</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 72</span>     <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">list_</span><span class="p">[</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">length_</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)];</span>
<span class="lineno"> 73</span>     <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
<span class="lineno"> 74</span>            <span class="p">((</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">!=</span> <span class="n">hash</span> <span class="o">||</span> <span class="n">key</span> <span class="o">!=</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()))</span> <span class="p">{</span>
<span class="lineno"> 75</span>       <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next_hash</span><span class="p">;</span>
<span class="lineno"> 76</span>     <span class="p">}</span>
<span class="lineno"> 77</span>     <span class="k">return</span> <span class="n">ptr</span><span class="p">;</span>
<span class="lineno"> 78</span>   <span class="p">}</span>
<span class="lineno"> 79</span> 
<span class="lineno"> 80</span>   <span class="kt">void</span> <span class="nf">Resize</span><span class="p">()</span> <span class="p">{</span>
<span class="lineno"> 81</span>     <span class="kt">uint32_t</span> <span class="n">new_length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="lineno"> 82</span>     <span class="k">while</span> <span class="p">(</span><span class="n">new_length</span> <span class="o">&lt;</span> <span class="n">elems_</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 83</span>       <span class="n">new_length</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="lineno"> 84</span>     <span class="p">}</span>
<span class="lineno"> 85</span>     <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">new_list</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LRUHandle</span><span class="o">*</span><span class="p">[</span><span class="n">new_length</span><span class="p">];</span>
<span class="lineno"> 86</span>     <span class="n">memset</span><span class="p">(</span><span class="n">new_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">new_length</span><span class="p">);</span>
<span class="lineno"> 87</span>     <span class="kt">uint32_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="lineno"> 88</span>     <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length_</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 89</span>       <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">h</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="lineno"> 90</span>       <span class="k">while</span> <span class="p">(</span><span class="n">h</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="lineno"> 91</span>         <span class="n">LRUHandle</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">next_hash</span><span class="p">;</span>
<span class="lineno"> 92</span>         <span class="n">Slice</span> <span class="n">key</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">();</span>
<span class="lineno"> 93</span>         <span class="kt">uint32_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
<span class="lineno"> 94</span>         <span class="n">LRUHandle</span><span class="o">**</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new_list</span><span class="p">[</span><span class="n">hash</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">new_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)];</span>
<span class="lineno"> 95</span>         <span class="n">h</span><span class="o">-&gt;</span><span class="n">next_hash</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="lineno"> 96</span>         <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
<span class="lineno"> 97</span>         <span class="n">h</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
<span class="lineno"> 98</span>         <span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="lineno"> 99</span>       <span class="p">}</span>
<span class="lineno">100</span>     <span class="p">}</span>
<span class="lineno">101</span>     <span class="n">assert</span><span class="p">(</span><span class="n">elems_</span> <span class="o">==</span> <span class="n">count</span><span class="p">);</span>
<span class="lineno">102</span>     <span class="k">delete</span><span class="p">[]</span> <span class="n">list_</span><span class="p">;</span>
<span class="lineno">103</span>     <span class="n">list_</span> <span class="o">=</span> <span class="n">new_list</span><span class="p">;</span>
<span class="lineno">104</span>     <span class="n">length_</span> <span class="o">=</span> <span class="n">new_length</span><span class="p">;</span>
<span class="lineno">105</span>   <span class="p">}</span>
<span class="lineno">106</span> <span class="p">};</span></code></pre></div>

<p><strong>HandleTable</strong>中的每个元素的实现是<strong>LRUHandle</strong>，LRU的实现就是依赖于prev和next指针，如果HashTable中的某个元素被访问，就会把该元素移到双链表的表头，如果朝双链表中插入一个元素，而双链表已达到最大程度，就直接移除掉双链表尾部的元素，因为该元素的访问日期一定比前面的所有元素早(思考一下问什么？)。<strong>HandleTable</strong>的实现是很经典的代码，通常的hash表都是这样实现的，比较有参考价值的代码是Resize函数。附带说一句，面试很容易遇到hashTable，hashMap之类的问题，要是把这里的哈希表看懂了，基本上这类问题你都可以回答得很圆满(特别要注意hash扩容的问题)。当然，类似的hash经典实现还可以去参考<strong>memcache</strong>和<strong>redis</strong>的相关代码，memcache里面的LRUCache还有一个slab的概念，是用于最大限度防止内存碎片并节约内存，而redis的扩容做得很好，不像memcache那样会把整个表锁住，这些都是经典代码，非常值得学习。</p>

<p>另外我再啰嗦一句，上面第13行，<strong>LRUHandle</strong>结构体的最后一个字段是char key_data[1]。C基础不太牢固的同学可能会疑问，为什么只用了1个字节。其实这里仅仅一个字节的占位符而已，由于这是结构体的最后一个元素，所以真正的数据可以接在后面，而不会影响其他字段。类似的还有<strong>redis</strong>中的<strong>sds</strong>数据结构，其声明为<code>struct sdshdr { szie_t len; char data[]; }</code>，这种形式也是很少见的，有兴趣的同学可以去google一下这到底是什么意思。把sdshdr理解了，你就能理解leveldb这里的HandleTable中的<code>char key_data[1]</code>的含义啦。</p>


  </article>

  <!-- <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'brgliuwei'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
 -->
  <!-- 多说评论框 start -->
<!--   data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址" -->
    <div class="ds-thread"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"brgliuwei"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();

    </script>
<!-- 多说公共JS代码 end -->

  <script type="text/javascript">
    var links = document.links;
     
    for (var i = 0, linksLength = links.length; i < linksLength; i++) {
       if (links[i].hostname != window.location.hostname) {
           links[i].target = '_blank';
       } 
    }
    function addBlankTargetForLinks() {
        $('a[href^="http"]').each(function() {
            $(this).attr('target', '_blank');
        })
    }
    
    $(document).bind('DOMNodeInserted', function(event) {
        addBlankTargetForLinks();
    });
</script>
 <!-- 为href跳转添加"_blank"标签，实现打开新标签页跳转 -->
</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">Blog of Finesse</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>Blog of Finesse</li>
          <li><a href="mailto:stupidlw@126.com">stupidlw@126.com</a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/brg-liuwei">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">brg-liuwei</span>
            </a>
          </li>
          

          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">岂能尽如人意 但求无愧我心
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
